<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The model tools for the integration of transient problems &mdash; GetFEM++</title>
    
    <link rel="stylesheet" href="../_static/getfem.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="GetFEM++" href="../index.html" />
    <link rel="up" title="The model description and basic model bricks" href="model.html" />
    <link rel="next" title="Small sliding contact with friction bricks" href="model_contact_friction.html" />
    <link rel="prev" title="Mindlin-Reissner plate model" href="model_Mindlin_plate.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/icon.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="model_contact_friction.html" title="Small sliding contact with friction bricks"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="model_Mindlin_plate.html" title="Mindlin-Reissner plate model"
             accesskey="P">前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../_static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" >User Documentation</a> &raquo;</li>
          <li><a href="model.html" accesskey="U">The model description and basic model bricks</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-model-tools-for-the-integration-of-transient-problems">
<span id="ud-model-time-integration"></span><span id="index-0"></span><h1>The model tools for the integration of transient problems<a class="headerlink" href="#the-model-tools-for-the-integration-of-transient-problems" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Although time integration scheme can be written directly using the model object by describing the problem to be solved at each iteration, the model object furnishes some basic tools to facilitate the writing of such schemes. These tools are based on the following basic principles:</p>
<ul>
<li><p class="first">The original variables of the model represent the state of the system to be solved at the current time step (say step n). This is the case even for a middle point scheme, mainly because if one needs to apply different schemes to different variables of the system, all variable should describe the system at a unique time step.</p>
</li>
<li><p class="first">Some data are added to the model to represent the state of the system at previous time steps. For classical one-step schemes (for the moment, only one-step schemes are provided), only the previous time step is stored. For instance if <cite>u</cite> is a variable (thus represented at step n), <cite>Previous_u</cite> will be the data representing the state of the variable at the previous time step (step n-1). Eventually, for future extension to multi-step methods, <cite>Previous2_u</cite> may represent the variable at time step n-2.</p>
</li>
<li><p class="first">Some intermediate variables are added to the model to represent the time derivative (and the second order time derivative for second order problem). For instance, if <cite>u</cite> is a variable, <cite>Dot_u</cite> will represent the first order time derivative of <cite>u</cite> and <cite>Dot2_u</cite> the second order one. One can refer to these variables in the model to add a brick on it or to use it in the weak form language. However, these are not considered to be independent variables, they will be linked to their corresponding original variable (in an affine way) by the time integration scheme. Most of the schemes need also the time derivative at the previous time step and add the data <cite>Previous_Dot_u</cite> and possibly <cite>Previous_Dot2_u</cite> to the model.</p>
</li>
<li><p class="first">A different time integration scheme can be applied on each variable of the model. Note that most of the time, multiplier variable and more generally variables for which no time derivative is used do not need a time integration scheme.</p>
</li>
<li><p class="first">The data <cite>t</cite> represent the time parameter and can be used (either in the weak form language or as parameter of some bricks). Before the assembly of the system, the data <cite>t</cite> is automatically updated to the time step <cite>n</cite>.</p>
</li>
<li><p class="first">The problem to be solved at each iteration correspond to the formulation of the transient problem in its natural (weak) formulation in which the velocity and the acceleration are expressed by the intermediate variables introduced. For instance, the translation into the weak form language of the problem</p>
<div class="math">
<p><img src="../_images/math/d03a88c4039f01cbcef74da11bb8016c922b7a81.png" alt="\dot{u}(t,x) - \Delta u(t,x) = \sin(t)"/></p>
</div><p>can simply be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Dot_u</span><span class="o">*</span><span class="n">Test_u</span> <span class="o">+</span> <span class="n">Grad_u</span><span class="p">.</span><span class="n">Grad_Test_u</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">Test_u</span>
</pre></div>
</div>
<p>(even though, of course, in this situation, the use of linear bricks is preferable for efficiency reasons)</p>
</li>
<li><p class="first">For all implemented one-step schemes, the time step can be changed from an iteration to another for both order one and order two in time problems (or even quasi-static problems).</p>
</li>
<li><p class="first">A scheme for second order in time problem (resp. first order in time) can be applied to a second or first order in time or even to a quasi-static problem (resp. to a first order or quasi-static problem) without any problem except that the initial data corresponding to the velocity/displacement have to be initialized with respect ot the order of the scheme. Conversely, of course, a scheme for first order problem cannot be applied to a second order in time problem.</p>
</li>
</ul>
<div class="section" id="the-implicit-theta-method-for-first-order-problems">
<h2>The implicit theta-method for first-order problems<a class="headerlink" href="#the-implicit-theta-method-for-first-order-problems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For a problem which reads</p>
<div class="math">
<p><img src="../_images/math/9816ecd4794bfd9bf675a6ba838aded52fc75c49.png" alt="M\dot{U} = F(U)"/></p>
</div><p>where <img class="math" src="../_images/math/ebe132de4d73ed657739ecb0f6523d6d027a0055.png" alt="F(U)" style="vertical-align: -4px"/> might be nonlinear (and may depend on some other variables for coupled problems), for <img class="math" src="../_images/math/3b43c3c537ab4ba51eebee44bac2476f4fd5474e.png" alt="dt" style="vertical-align: 0px"/> a time step, <img class="math" src="../_images/math/bf46a55ed6437e573c16498b16a01512d77ac97f.png" alt="V = \dot{U}" style="vertical-align: 0px"/> and <img class="math" src="../_images/math/bac82b5a986bab239f01ed2a18817ce99f207a84.png" alt="U^n, V^n" style="vertical-align: -4px"/> the approximation of <img class="math" src="../_images/math/34f52fe2209c745a05c1c6e8922aa00f850250d8.png" alt="U, V" style="vertical-align: -4px"/> at time <img class="math" src="../_images/math/e7e26ec665d056e87edf55caac2cf100b3c24efb.png" alt="ndt" style="vertical-align: 0px"/>, theta-method reads</p>
<div class="math">
<p><img src="../_images/math/efe871010b5ae520474b6bb7d2f2981341e15aa4.png" alt="\left\{ \begin{array}{l}
U^n = U^{n-1} + dt(\theta V^n + (1-\theta) V^{n-1}), \\
MV^n = F(U^n),
\end{array}\right."/></p>
</div><p>for <img class="math" src="../_images/math/d9542ceaa01b0d7fb83027afa78dc8d4d07209ba.png" alt="\theta \in (0, 1]" style="vertical-align: -5px"/> the parameter of the theta-method (for <img class="math" src="../_images/math/8656595bf44ec840dac700925abe3bcbccab0b46.png" alt="\theta = 0" style="vertical-align: 0px"/>, the method corresponds to the forward Euler method and is not an implicit scheme) and for <img class="math" src="../_images/math/e4ae1fff2d0846b302ac140b31de0fc00515ee29.png" alt="U^{n-1}, V^{n-1}" style="vertical-align: -4px"/> given.</p>
<p>Before the first time step, <img class="math" src="../_images/math/55fa712825183213d03d46db16f6655cbf459e34.png" alt="U^0" style="vertical-align: 0px"/> should be initialized, however, <img class="math" src="../_images/math/590184fd3f8152c481b2abd2ce7c3a9219864038.png" alt="V^0" style="vertical-align: 0px"/> is also needed (except for <img class="math" src="../_images/math/72ad431cc263034d8221a41fe80cc1bcf0164959.png" alt="\theta = 1" style="vertical-align: -1px"/>). In this example, it should correspond to <img class="math" src="../_images/math/5d6240925cfdd6b6e2d5d46122cddf0cff514270.png" alt="M^{-1}F(U^0)" style="vertical-align: -4px"/>. For a general coupled problem where <img class="math" src="../_images/math/5d1e4485dc90c450e8c76826516c1b2ccb8fce16.png" alt="M" style="vertical-align: 0px"/> might be singular, a generic precomputation of <img class="math" src="../_images/math/590184fd3f8152c481b2abd2ce7c3a9219864038.png" alt="V^0" style="vertical-align: 0px"/> is difficult to obtain. Thus <img class="math" src="../_images/math/590184fd3f8152c481b2abd2ce7c3a9219864038.png" alt="V^0" style="vertical-align: 0px"/> have to be furnisded also. Alternatively (see below) the model object (and the standard solve) furnishes a mean to evaluate them thanks to the application of a Backward Euler scheme on a (very) small time step.</p>
<p>The following formula can be deduced for the time derivative:</p>
<div class="math">
<p><img src="../_images/math/0567964344a010d6460ba47fff3d9d8d902b538a.png" alt="V^n = \frac{U^n - U^{n-1}}{\theta dt} - \frac{1-\theta}{\theta}V^{n-1}"/></p>
</div><p>When applying this scheme to a variable &#8220;u&#8221; of the model, the following affine dependent variable is added to the model:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Dot_u&quot;</span>
</pre></div>
</div>
<p>which represent the time derivative of the variable and can be used in some brick definition.</p>
<p>The following data are also added:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Previous_u&quot;</span><span class="p">,</span> <span class="s">&quot;Previous_Dot_u&quot;</span>
</pre></div>
</div>
<p>which correspond to the values of &#8220;u&#8221; and &#8220;Dot_u&#8221; at the previous time step.</p>
<p>Before the solve, the data  &#8220;Previous_u&#8221; (corresponding to <img class="math" src="../_images/math/55fa712825183213d03d46db16f6655cbf459e34.png" alt="U^0" style="vertical-align: 0px"/> in the example) has to be initialized (except for <img class="math" src="../_images/math/72ad431cc263034d8221a41fe80cc1bcf0164959.png" alt="\theta = 1" style="vertical-align: -1px"/>). Again, &#8220;Previous_Dot_u&#8221; has to be either initialized or pre-computed as described in the next section. The affine dependence of &#8220;Dot_u&#8221; is thus given by:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Dot_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">Previous_u</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">Previous_Dot_u</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">theta</span>
</pre></div>
</div>
<p>Which means that &#8220;Dot_u&#8221; will be replaced at assembly time by its expression in term of &#8220;u&#8221; (multipied by <img class="math" src="../_images/math/5d0f4b6acd2372fe9a8396e70fd95c7436bc1fd6.png" alt="1/(\theta*dt)" style="vertical-align: -5px"/>) and in term of a constant remaining part depending on the previous time step.
The addition of this scheme to a variable is to be done thanks to:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_theta_method_for_first_order</span><span class="p">(</span><span class="n">model</span> <span class="o">&amp;</span><span class="n">md</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">varname</span><span class="p">,</span> <span class="n">scalar_type</span> <span class="n">theta</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="precomputation-of-velocity-acceleration">
<span id="precomp-time-der-section"></span><h2>Precomputation of velocity/acceleration<a class="headerlink" href="#precomputation-of-velocity-acceleration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Most of the time integration schemes (except, for instance, the backward Euler scheme) needs the pre-computation of the first or second order time derivative before the initial time step (for instance <img class="math" src="../_images/math/590184fd3f8152c481b2abd2ce7c3a9219864038.png" alt="V^0" style="vertical-align: 0px"/> for the theta-method for first order problems, <img class="math" src="../_images/math/5d169d7327b5ffb476ced5cd415c41e21e121198.png" alt="A^0" style="vertical-align: 0px"/> for second order problems ...).</p>
<p>The choice is let to the user to either initialize these derivative or to ask to the model to automatically approximate them.</p>
<p>The method used (for the moment) to approximate the supplementary derivatives may be explained in the example of the solve of</p>
<div class="math">
<p><img src="../_images/math/9816ecd4794bfd9bf675a6ba838aded52fc75c49.png" alt="M\dot{U} = F(U)"/></p>
</div><p>with a theta-method (see the previous section). In order to approximate <img class="math" src="../_images/math/b4df5a1be0fe6fc35e2bcd0bf4b7e1733edcfd36.png" alt="V_0" style="vertical-align: -3px"/>, the theta-method is applied for <img class="math" src="../_images/math/72ad431cc263034d8221a41fe80cc1bcf0164959.png" alt="\theta = 1" style="vertical-align: -1px"/> (i.e. a backward Euler scheme) on a very small time step. This is possible since the  backward Euler do not need an initial time derivative. Then the time derivative computed thanks to the  backward Euler at the end of the very small time step is simply used as an approximation of the initial time derivative.</p>
<p>For a model <cite>md</cite>, the following instructions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">perform_init_time_derivative</span><span class="p">(</span><span class="n">ddt</span><span class="p">);</span>
<span class="n">standard_solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
</pre></div>
</div>
<p>allows to perform automatically the approximation of the initial time derivative. The parameter <cite>ddt</cite> corresponds to the small time step used to perform the aproximation. Typically, <cite>dtt = dt/20</cite> could be used where  <cite>dt</cite> is the time step used to approximate the transient problem (see the example below).</p>
</div>
<div class="section" id="the-implicit-theta-method-for-second-order-problems">
<h2>The implicit theta-method for second-order problems<a class="headerlink" href="#the-implicit-theta-method-for-second-order-problems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For a problem which reads</p>
<div class="math">
<p><img src="../_images/math/873a5f513053a4c9f887843d46a84d398a23664a.png" alt="M\ddot{U} = F(U)"/></p>
</div><p>where <img class="math" src="../_images/math/ebe132de4d73ed657739ecb0f6523d6d027a0055.png" alt="F(U)" style="vertical-align: -4px"/> might be nonlinear (and may depend on some othere variables for coupled problems), for <img class="math" src="../_images/math/3b43c3c537ab4ba51eebee44bac2476f4fd5474e.png" alt="dt" style="vertical-align: 0px"/> a time step, <img class="math" src="../_images/math/bf46a55ed6437e573c16498b16a01512d77ac97f.png" alt="V = \dot{U}" style="vertical-align: 0px"/>, <img class="math" src="../_images/math/133c6a5d85dcc6deae02e41852cb5f521ceb0d50.png" alt="A = \ddot{U}" style="vertical-align: 0px"/> and <img class="math" src="../_images/math/ae3236fef4997d9befaf0b9e3ae48750ec8e095c.png" alt="U^n, V^n, A^n" style="vertical-align: -4px"/> the approximation of <img class="math" src="../_images/math/50250aee75b00342640fb8c23a63f82af87d03c2.png" alt="U, V, A" style="vertical-align: -4px"/> at time <img class="math" src="../_images/math/e7e26ec665d056e87edf55caac2cf100b3c24efb.png" alt="ndt" style="vertical-align: 0px"/>, the first oder theta-method reads</p>
<div class="math">
<p><img src="../_images/math/83ed895a1187b49d46a3ffef8edf0df5b4b6ab83.png" alt="\left\{ \begin{array}{l}
U^n = U^{n-1} + dt(\theta V^n + (1-\theta) V^{n-1}), \\
V^n = V^{n-1} + dt(\theta A^n + (1-\theta) A^{n-1}), \\
MA^n = F(U^n),
\end{array}\right."/></p>
</div><p>for <img class="math" src="../_images/math/d9542ceaa01b0d7fb83027afa78dc8d4d07209ba.png" alt="\theta \in (0, 1]" style="vertical-align: -5px"/> the parameter of the theta-method (for <img class="math" src="../_images/math/8656595bf44ec840dac700925abe3bcbccab0b46.png" alt="\theta = 0" style="vertical-align: 0px"/>, the method correspond to the forward Euler method and is not an implicit scheme) and for <img class="math" src="../_images/math/4a9b5873e10d628fa6345fa1b6b47271be3e7ed9.png" alt="U^{n-1}, V^{n-1}, A^{n-1}" style="vertical-align: -4px"/> given.</p>
<p>At the first time step, <img class="math" src="../_images/math/003f409a156046ddce88f179f5f3017cf44b5916.png" alt="U^0, V^0" style="vertical-align: -4px"/> should be given and <img class="math" src="../_images/math/5d169d7327b5ffb476ced5cd415c41e21e121198.png" alt="A^0" style="vertical-align: 0px"/> is to be given or pre-computed (except for <img class="math" src="../_images/math/72ad431cc263034d8221a41fe80cc1bcf0164959.png" alt="\theta = 1" style="vertical-align: -1px"/>).</p>
<p>The following formula can be deduced for the time derivative:</p>
<div class="math">
<p><img src="../_images/math/e4f874d49d11e13b44bc16fe71cec9cfeaebf3f6.png" alt="V^n = \frac{U^n - U^{n-1}}{\theta dt} - \frac{1-\theta}{\theta}V^{n-1}

A^n = \frac{U^n - U^{n-1}}{\theta^2 dt^2} - \frac{1}{\theta^2dt}V^{n-1} - \frac{1-\theta}{\theta}A^{n-1}"/></p>
</div><p>When aplying this scheme to a variable &#8220;u&#8221; of the model, the following affine dependent variables are added to the model:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Dot_u&quot;</span><span class="p">,</span> <span class="s">&quot;Dot2_u&quot;</span>
</pre></div>
</div>
<p>which represent the first and second order time derivative of the variable and can be used in some brick definition.</p>
<p>The following data are also added:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Previous_u&quot;</span><span class="p">,</span> <span class="s">&quot;Previous_Dot_u&quot;</span><span class="p">,</span> <span class="s">&quot;Previous_Dot2_u&quot;</span>
</pre></div>
</div>
<p>which correspond to the values of &#8220;u&#8221;, &#8220;Dot_u&#8221;  and &#8220;Dot2_u&#8221; at the previous time step.</p>
<p>Before the solve, the data  &#8220;Previous_u&#8221; and &#8220;Previous_Dot_u&#8221; (corresponding to <img class="math" src="../_images/math/55fa712825183213d03d46db16f6655cbf459e34.png" alt="U^0" style="vertical-align: 0px"/> in the example) have to be initialized and &#8220;Previous_Dot2_u&#8221; should be either initialized or precomputed (see the previous section, and except for <img class="math" src="../_images/math/72ad431cc263034d8221a41fe80cc1bcf0164959.png" alt="\theta = 1" style="vertical-align: -1px"/>). The affine dependences are thus given by:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Dot_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">Previous_u</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">Previous_Dot_u</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">theta</span>
<span class="n">Dot2_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">Previous_u</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">Previous_Dot_u</span><span class="o">/</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">Previous_Dot2_u</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">theta</span>
</pre></div>
</div>
<p>The addition of this scheme to a variable is to be done thanks to:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_theta_method_for_second_order</span><span class="p">(</span><span class="n">model</span> <span class="o">&amp;</span><span class="n">md</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">varname</span><span class="p">,</span>
                                  <span class="n">scalar_type</span> <span class="n">theta</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="the-implicit-newmark-scheme-for-second-order-problems">
<h2>The implicit Newmark scheme for second order problems<a class="headerlink" href="#the-implicit-newmark-scheme-for-second-order-problems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For a problem which reads</p>
<div class="math">
<p><img src="../_images/math/873a5f513053a4c9f887843d46a84d398a23664a.png" alt="M\ddot{U} = F(U)"/></p>
</div><p>where <img class="math" src="../_images/math/ebe132de4d73ed657739ecb0f6523d6d027a0055.png" alt="F(U)" style="vertical-align: -4px"/> might be nonlinear (and may depend on some othere variables for coupled problems), for <img class="math" src="../_images/math/3b43c3c537ab4ba51eebee44bac2476f4fd5474e.png" alt="dt" style="vertical-align: 0px"/> a time step, <img class="math" src="../_images/math/bf46a55ed6437e573c16498b16a01512d77ac97f.png" alt="V = \dot{U}" style="vertical-align: 0px"/>, <img class="math" src="../_images/math/133c6a5d85dcc6deae02e41852cb5f521ceb0d50.png" alt="A = \ddot{U}" style="vertical-align: 0px"/> and <img class="math" src="../_images/math/ae3236fef4997d9befaf0b9e3ae48750ec8e095c.png" alt="U^n, V^n, A^n" style="vertical-align: -4px"/> the approximation of <img class="math" src="../_images/math/50250aee75b00342640fb8c23a63f82af87d03c2.png" alt="U, V, A" style="vertical-align: -4px"/> at time <img class="math" src="../_images/math/e7e26ec665d056e87edf55caac2cf100b3c24efb.png" alt="ndt" style="vertical-align: 0px"/>, the first oder theta-method reads</p>
<div class="math">
<p><img src="../_images/math/d9b35e353729bb6aa90de78fa1a65cc91972e870.png" alt="\left\{ \begin{array}{l}
U^n = U^{n-1} + dtV^n + \frac{dt^2}{2}(2\beta V^n + (1-2\beta) V^{n-1}), \\
V^n = V^{n-1} + dt(\gamma A^n + (1-\gamma) A^{n-1}), \\
MA^n = F(U^n),
\end{array}\right."/></p>
</div><p>for <img class="math" src="../_images/math/2af80465120c88fbac9dd602cc72bb51333557ef.png" alt="\beta \in (0, 1]" style="vertical-align: -5px"/> and <img class="math" src="../_images/math/917a3e8ae98af862591e4dc0b0ce5d3842b7bdfa.png" alt="\gamma \in [1/2, 1]" style="vertical-align: -5px"/> are the parameters of the Newmark scheme and for <img class="math" src="../_images/math/4a9b5873e10d628fa6345fa1b6b47271be3e7ed9.png" alt="U^{n-1}, V^{n-1}, A^{n-1}" style="vertical-align: -4px"/> given.</p>
<p>At the first time step, <img class="math" src="../_images/math/003f409a156046ddce88f179f5f3017cf44b5916.png" alt="U^0, V^0" style="vertical-align: -4px"/> should be given and <img class="math" src="../_images/math/5d169d7327b5ffb476ced5cd415c41e21e121198.png" alt="A^0" style="vertical-align: 0px"/> is to be given or pre-computed (except for <img class="math" src="../_images/math/474371ff930f64217b5cfcd60a955a374cd81c87.png" alt="\beta = 1/2, \gamma = 1" style="vertical-align: -5px"/>).</p>
<p>The following formula can be deduced for the time derivative:</p>
<div class="math">
<p><img src="../_images/math/fd370aff1206dcfaaae01aecac3f7cf6b9881144.png" alt="V^n = \frac{\gamma}{\beta dt}(U^n - U^{n-1}) + \frac{\beta-\gamma}{\beta}V^{n-1} + dt(1-\frac{\gamma}{2\beta})A^{n-1}

A^n = \frac{U^n - U^{n-1}}{\beta dt^2} - \frac{1}{\beta dt}V^{n-1} - (1/2-\beta)A^{n-1}"/></p>
</div><p>When aplying this scheme to a variable &#8220;u&#8221; of the model, the following affine dependent variables are added to the model:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Dot_u&quot;</span><span class="p">,</span> <span class="s">&quot;Dot2_u&quot;</span>
</pre></div>
</div>
<p>which represent the first and second order time derivative of the variable and can be used in some brick definition.</p>
<p>The following data are also added:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Previous_u&quot;</span><span class="p">,</span> <span class="s">&quot;Previous_Dot_u&quot;</span><span class="p">,</span> <span class="s">&quot;Previous_Dot2_u&quot;</span>
</pre></div>
</div>
<p>which correspond to the values of &#8220;u&#8221;, &#8220;Dot_u&#8221;  and &#8220;Dot2_u&#8221; at the previous time step.</p>
<p>Before the first solve, the data  &#8220;Previous_u&#8221; and &#8220;Previous_Dot_u&#8221; (corresponding to <img class="math" src="../_images/math/55fa712825183213d03d46db16f6655cbf459e34.png" alt="U^0" style="vertical-align: 0px"/> in the example) have to be initialized. The data &#8220;Previous_Dot2_u&#8221; is to be given or precomputed (see <a class="reference internal" href="#precomp-time-der-section"><em>Precomputation of velocity/acceleration</em></a> and except for <img class="math" src="../_images/math/474371ff930f64217b5cfcd60a955a374cd81c87.png" alt="\beta = 1/2, \gamma = 1" style="vertical-align: -5px"/>).</p>
<p>The addition of this scheme to a variable is to be done thanks to:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_Newmark_scheme</span><span class="p">(</span><span class="n">model</span> <span class="o">&amp;</span><span class="n">md</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">varname</span><span class="p">,</span>
                   <span class="n">scalar_type</span> <span class="n">beta</span><span class="p">,</span> <span class="n">scalar_type</span> <span class="n">gamma</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="transient-terms">
<h2>Transient terms<a class="headerlink" href="#transient-terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>As it has been explained in previous sections, some intermediate variables are added to the model in order to represent the time derivative of the variables on which the scheme is applied. Once again, if &#8220;u&#8221; is such a variable, &#8220;Dot_u&#8221; will represent the time derivative of &#8220;u&#8221; approximated by the used scheme.</p>
<p>This also mean that &#8220;Dot_u&#8221; (and &#8220;Dot2_u&#8221; in order two in time problems) can be used to express the transient terms. In the weak form language, the term:</p>
<div class="math">
<p><img src="../_images/math/320eba831d4a50912746187672a4f913b0c11365.png" alt="\int_{\Omega} \dot{u} v dx"/></p>
</div><p>can be simply expressed by:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Dot_u</span><span class="o">*</span><span class="n">Test_u</span>
</pre></div>
</div>
<p>Similarly, every existing model brick of <em>GetFEM++</em> can be applied to &#8220;Dot_u&#8221;. This is the case for instance with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">add_mass_brick</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;Dot_u&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>which adds the same transient term.</p>
<p>VERY IMPORTANT: When adding an existing model brick applied to an affine dependent variable such as &#8220;Dot_u&#8221;, it is always assumed that the corresponding test function is the one of the corresponding original variable (i.e. &#8220;Test_u&#8221; here). In other words, &#8220;Test_Dot_u&#8221;, the test variable corresponding to the velocity, is not used. This corresponds to the choice made to solve the problem in term of the original variable, so that the test function corresponds to the original variable.</p>
<p>Another example of model brick which can be used to account for a Kelvin-Voigt linearized viscosity term is the linearized elasticity brick:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">add_isotropic_linearized_elasticity_brick</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;Dot_u&quot;</span><span class="p">,</span> <span class="s">&quot;lambda_viscosity&quot;</span><span class="p">,</span> <span class="s">&quot;mu_viscosity&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>when applied to an order two transient elasticity problem.</p>
</div>
<div class="section" id="computation-on-the-sequence-of-time-steps">
<h2>Computation on the sequence of time steps<a class="headerlink" href="#computation-on-the-sequence-of-time-steps" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Typically, the solve on the different time steps will take the following form:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">scalar_type</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// time loop</span>

  <span class="c1">// Eventually compute here some time dependent terms</span>

  <span class="n">iter</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
  <span class="n">getfem</span><span class="o">::</span><span class="n">standard_solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

  <span class="c1">// + Do something with the solution (plot or store it)</span>

  <span class="n">model</span><span class="p">.</span><span class="n">shift_variables_for_time_integration</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the call of the method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">shift_variables_for_time_integration</span><span class="p">();</span>
</pre></div>
</div>
<p>is needed between two time step since it will copy the current value of the variables (<cite>u</cite> and <cite>Dot_u</cite> for instance) to the previous ones (<cite>Pevious_u</cite> and <cite>Previous_Dot_u</cite>).</p>
</div>
<div class="section" id="boundary-conditions">
<h2>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Standard boundary conditions can of course be applied normally to the different variables of the unknown. By default, applying Dirichlet, Neumann or contact boundary conditions to the unknown simply means that the conditions are prescribed on the variable at the current time step n.</p>
</div>
<div class="section" id="small-example-heat-equation">
<h2>Small example: heat equation<a class="headerlink" href="#small-example-heat-equation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The complete compilable program corresponds to the test program <tt class="file docutils literal"><span class="pre">tests/heat_equation.cc</span></tt> of <em>GetFEM++</em> distribution. See also <tt class="file docutils literal"><span class="pre">/interface/tests/matlab/demo_wave_equation.m</span></tt> for an example of order two in time problem with the Matlab interface.</p>
<p>Assuming that <cite>mf_u</cite> and <cite>mim</cite> are valid finite element and integration methods defined on a valid mesh, the following code will perform the approximation of the evolution of the temperature on the mesh assuming a unitary diffusion coefficient:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">model</span> <span class="n">model</span><span class="p">;</span>
<span class="n">model</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Main unknown of the problem</span>

<span class="n">getfem</span><span class="o">::</span><span class="n">add_generic_elliptic_brick</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">);</span> <span class="c1">// Laplace term</span>

<span class="c1">// Volumic source term.</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">add_source_term_generic_assembly_brick</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;sin(t)*Test_u&quot;</span><span class="p">);</span>


<span class="c1">// Dirichlet condition.</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">add_Dirichlet_condition_with_multipliers</span>
    <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">DIRICHLET_BOUNDARY_NUM</span><span class="p">);</span>

<span class="c1">// transient part.</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">add_theta_method_for_first_order</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">add_mass_brick</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="s">&quot;Dot_u&quot;</span><span class="p">);</span>

<span class="n">gmm</span><span class="o">::</span><span class="n">iteration</span> <span class="n">iter</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">40000</span><span class="p">);</span>

<span class="n">model</span><span class="p">.</span><span class="n">set_time</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>        <span class="c1">// Init time is 0 (not mandatory)</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_time_step</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>   <span class="c1">// Init of the time step.</span>

<span class="c1">// Null initial value for the temperature.</span>
<span class="n">gmm</span><span class="o">::</span><span class="n">clear</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">set_real_variable</span><span class="p">(</span><span class="s">&quot;Previous_u&quot;</span><span class="p">));</span>

<span class="c1">// Automatic computatio of Previous_Dot_u</span>
<span class="n">model</span><span class="p">.</span><span class="n">perform_init_time_derivative</span><span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mf">20.</span><span class="p">);</span>
<span class="n">iter</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">standard_solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>


<span class="c1">// Iterations in time</span>
<span class="k">for</span> <span class="p">(</span><span class="n">scalar_type</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">iter</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
  <span class="n">getfem</span><span class="o">::</span><span class="n">standard_solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

  <span class="c1">// + Do something with the solution (plot or store it)</span>

  <span class="c1">// Copy the current variables &quot;u&quot; and &quot;Dot_u&quot; into &quot;Previous_u&quot;</span>
  <span class="c1">// and &quot;Previous_Dot_u&quot;.</span>
  <span class="n">model</span><span class="p">.</span><span class="n">shift_variables_for_time_integration</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="implicit-explicit-some-terms">
<h2>Implicit/explicit some terms<a class="headerlink" href="#implicit-explicit-some-terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>...</p>
</div>
<div class="section" id="explicit-schemes">
<h2>Explicit schemes<a class="headerlink" href="#explicit-schemes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>...</p>
</div>
<div class="section" id="time-step-adaptation">
<h2>Time step adaptation<a class="headerlink" href="#time-step-adaptation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>...</p>
</div>
<div class="section" id="quasi-static-problems">
<h2>Quasi-static problems<a class="headerlink" href="#quasi-static-problems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>...</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <p class="logo"><a href="../index.html">
    <img class="logo" src="../_static/logo_getfem_small.png" alt="Logo"/>
  </a></p>
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">The model tools for the integration of transient problems</a><ul>
<li><a class="reference internal" href="#the-implicit-theta-method-for-first-order-problems">The implicit theta-method for first-order problems</a></li>
<li><a class="reference internal" href="#precomputation-of-velocity-acceleration">Precomputation of velocity/acceleration</a></li>
<li><a class="reference internal" href="#the-implicit-theta-method-for-second-order-problems">The implicit theta-method for second-order problems</a></li>
<li><a class="reference internal" href="#the-implicit-newmark-scheme-for-second-order-problems">The implicit Newmark scheme for second order problems</a></li>
<li><a class="reference internal" href="#transient-terms">Transient terms</a></li>
<li><a class="reference internal" href="#computation-on-the-sequence-of-time-steps">Computation on the sequence of time steps</a></li>
<li><a class="reference internal" href="#boundary-conditions">Boundary conditions</a></li>
<li><a class="reference internal" href="#small-example-heat-equation">Small example: heat equation</a></li>
<li><a class="reference internal" href="#implicit-explicit-some-terms">Implicit/explicit some terms</a></li>
<li><a class="reference internal" href="#explicit-schemes">Explicit schemes</a></li>
<li><a class="reference internal" href="#time-step-adaptation">Time step adaptation</a></li>
<li><a class="reference internal" href="#quasi-static-problems">Quasi-static problems</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="model_Mindlin_plate.html"
                        title="前の章へ">Mindlin-Reissner plate model</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="model_contact_friction.html"
                        title="次の章へ">Small sliding contact with friction bricks</a></p>            <h3>Download</h3>
            <p><a href="../download.html">Download GetFEM++ </a></p>
	    <h3>Main documentations</h3>
	    <ul>
              
	      <li><a href="index.html">GetFEM++ User documentation</a></li>
              <li><a href="../python/index.html">Python Interface</a></li>
	      <li><a href="../matlab/index.html">Matlab Interface</a></li>
	      <li><a href="../scilab/index.html">Scilab Interface</a></li>
	      <li><a href="../gmm/index.html"> Gmm++</a></li>
	      <li><a href="../project/index.html"> GetFEM++ project</a></li>
            </ul>

            <h3>Other resources</h3>
            <ul>
              <li><a href="../screenshots/shots.html">Screenshots</a></li>
              <li><a href="../links.html">Related links</a></li>
	      <li><a href="https://savannah.nongnu.org/projects/getfem">Hosted by Savannah </a></li>
              
              
            </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="model_contact_friction.html" title="Small sliding contact with friction bricks"
             >次へ</a> |</li>
        <li class="right" >
          <a href="model_Mindlin_plate.html" title="Mindlin-Reissner plate model"
             >前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../_static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" >User Documentation</a> &raquo;</li>
          <li><a href="model.html" >The model description and basic model bricks</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2004-2018 GetFEM++ project.
    </div>
  </body>
</html>